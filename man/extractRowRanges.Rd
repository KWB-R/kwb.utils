% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/blockRange.R
\name{extractRowRanges}
\alias{extractRowRanges}
\title{Extract Row Ranges by Pattern}
\usage{
extractRowRanges(
  x,
  pattern,
  column = NULL,
  starts = NULL,
  startOffset = 1L,
  stopOffset = 1L,
  nameByMatch = FALSE,
  nameColumnsByMatch = TRUE,
  renumber = TRUE
)
}
\arguments{
\item{x}{data frame or matrix or vector of character (representing e.g. the 
rows read from a text file)}

\item{pattern}{pattern to be searched for, either in \code{[, column]} (if
\code{x} is a data frame or a matrix) or in \code{x} (if \code{x} is a 
vector of character)}

\item{column}{name of column in which to search for \emph{pattern} if 
\code{x} is a data frame or a matrix}

\item{starts}{optional. Vector of indices representing the starts of the row
ranges to be extracted. This argument overrides \code{pattern}. Instead of
using the pattern to find the start indices, the indices given here are 
used.}

\item{startOffset}{row offset to be added to row number in which the pattern
matches}

\item{stopOffset}{row offset to be subtracted from row number in which the
pattern matches}

\item{nameByMatch}{logical. if \code{TRUE}, the elements in the result list
are named by the matching values. Defaults to \code{FALSE}.}

\item{nameColumnsByMatch}{if \code{TRUE} (default) the columns of the result
data frames or matrices are named (if \code{x} is a data frame or a matrix)}

\item{renumber}{if \code{TRUE} (default) and \code{x} is a data frame or a 
matrix the row names of the result data frames or matrices are reset to 
\code{NULL}, i.e. their rows are renumbered}
}
\value{
list of data frames or list of matrices or list of vectors of
  character. Each list element represents one section of the input, found
  between two consecutive matches of \code{pattern}.
}
\description{
Extract Row Ranges by Pattern
}
\examples{
textLines <- c(
  "Date,Value",
  "1.1.,1",
  "2.1.,2",
  ",",
  "Date,Value",
  "3.1.,3",
  "4.1.,4",
  ",",
  "Date,Value",
  "5.1.,5",
  "6.1.,6"
)

# Convert textLines to data frame. The function should be able to handle both.
(dataFrame <- read.table(text = textLines, sep = ",", stringsAsFactors = FALSE))

# stopOffset = 2L: skip empty line at the bottom of each sub-table
extractRowRanges(
  textLines,
  pattern = "Date", 
  stopOffset = 2L,
)

extractRowRanges(
  dataFrame,
  pattern = "Date",
  column = "V1",
  stopOffset = 2L
)

# Extract sections after a header line
# startOffset = 2L: skip empty line after header "topic: ..."
textLines <- c(
  "topic: A",
  "",
  " a.1",
  " a.2",
  " a.3",
  "topic: B",
  "",
  " b.1",
  "topic: C",
  "",
  " c.1",
  " c.2"
)

extractRowRanges(
  textLines,
  pattern = "topic", 
  startOffset = 2L,
  nameByMatch = TRUE
)
}
